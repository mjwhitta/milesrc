# If not running interactively, don't do anything
[[ $- == *i* ]] || return

# Lots of old stuff in here.

# {{{ Colors
declare -A FX FG BG 2>/dev/null

if [[ $? == 0 ]]; then
    FX[default]="\e[0m"
    FX[normal]="\e[0m"
    FX[reset]="\e[0m"
    FX[bold]="\e[1m"
    FX[dim]="\e[2m"
    FX[faint]="\e[2m"
    FX[italic]="\e[3m"
    FX[underline]="\e[4m"
    FX[blink]="\e[5m"
    FX[blink_slow]="\e[5m"
    FX[blink_rapid]="\e[6m"
    FX[inverse]="\e[7m"
    FX[negative]="\e[7m"
    FX[swap]="\e[7m"
    FX[conceal]="\e[8m"
    FX[hide]="\e[8m"
    FX[crossed_out]="\e[9m"
    FX[strikethrough]="\e[9m"
    FX[fraktur]="\e[20m"
    FX[no_bold]="\e[21m"
    FX[no_dim]="\e[22m"
    FX[no_faint]="\e[22m"
    FX[no_italic]="\e[23m"
    FX[no_underline]="\e[24m"
    FX[no_blink]="\e[25m"
    FX[no_blink_slow]="\e[25m"
    FX[no_blink_rapid]="\e[26m"
    FX[no_inverse]="\e[27m"
    FX[no_negative]="\e[27m"
    FX[no_swap]="\e[27m"
    FX[no_conceal]="\e[28m"
    FX[no_hide]="\e[28m"
    FX[no_crossed_out]="\e[29m"
    FX[no_strikethrough]="\e[29m"

    FG[default]="\e[39m"
    BG[default]="\e[49m"

    FG[black]="\e[30m"
    BG[black]="\e[40m"
    FG[red]="\e[31m"
    BG[red]="\e[41m"
    FG[green]="\e[32m"
    BG[green]="\e[42m"
    FG[yellow]="\e[33m"
    BG[yellow]="\e[43m"
    FG[blue]="\e[34m"
    BG[blue]="\e[44m"
    FG[magenta]="\e[35m"
    BG[magenta]="\e[45m"
    FG[cyan]="\e[36m"
    BG[cyan]="\e[46m"
    FG[white]="\e[37m"
    BG[white]="\e[47m"
    FG[light_black]="\e[90m"
    BG[light_black]="\e[100m"
    FG[light_red]="\e[91m"
    BG[light_red]="\e[101m"
    FG[light_green]="\e[92m"
    BG[light_green]="\e[102m"
    FG[light_yellow]="\e[93m"
    BG[light_yellow]="\e[103m"
    FG[light_blue]="\e[94m"
    BG[light_blue]="\e[104m"
    FG[light_magenta]="\e[95m"
    BG[light_magenta]="\e[105m"
    FG[light_cyan]="\e[96m"
    BG[light_cyan]="\e[106m"
    FG[light_white]="\e[97m"
    BG[light_white]="\e[107m"

    # Fill the color maps.
    for color in {000..256}; do
        FG[$color]="\e[38;5;${color}m"
        BG[$color]="\e[48;5;${color}m"
    done; unset color

    export FX
    export FG
    export BG
fi
# }}}

# {{{ Env Vars
# Terminal stuff
export TERM="xterm-256color"
# [[ -n $XTERM_VERSION ]] || export TERM="screen-256color"
export TERMCMD="xterm"

# Command args
case "$(uname -s)" in
    "Darwin") export NANO_ARGS="-m" ;;
    *) export NANO_ARGS="-um" ;;
esac

# Android
[[ -d $HOME/Android/Sdk ]] && export ANDROID_HOME="$HOME/Android/Sdk"
# }}}

# {{{ PATH
# }}}

# {{{ Prompt
# }}}

# {{{ Aliases
[[ -z $(installed nano) ]] || alias nano="\nano $NANO_ARGS"
alias weather="clear; curl -s wttr.in/~Lafayette,IN | head -n -2"
# }}}

# {{{ Functions
add_to_path() {
    local arg
    local dir

    for arg in "$@"; do
        if [[ -d $arg ]]; then
            for dir in $(
                find -L $arg -name ".*" -prune -o -type d -print \
                2>/dev/null
            ); do
                \cd $dir
                export PATH="$PATH:$(pwd)"
                \cd - >/dev/null
            done
        fi
    done
}

if [[ -n $(installed docker) ]]; then
    dips() {
        if [[ -z $(installed jq) ]]; then
            echo "jq is not installed"
            return
        fi

        docker network inspect ${1:-bridge} | \
            jq -cMrS ".[].Containers[]|.Name,.IPv4Address" | \
            sed "\$!N;s/\n/\t/"
    }

    alias dps="docker ps -a"

    dsh() {
        if [[ $# -eq 0 ]]; then
            echo "You need to specify a container"
            return
        fi

        local -a args=($@)
        local image="${args[-2]}"
        local name="${args[-1]}"
        args=(${args[@]%$name})
        args=(${args[@]%$image})

        if [[ -z $(docker ps | \grep -w "$name") ]]; then
            docker run -di --name $name --rm -t $image bash
        fi

        local shell="bash"
        for s in /usr/bin/zsh /bin/zsh /bin/bash /bin/sh; do
            docker exec -it $name test -f $s
            [[ $# -eq 0 ]] && shell="$s" && break
        done

        docker exec -it $name $shell
    }
fi

list_displays() {
    local dir="/tmp/.X11-unix"
    local x

    if [[ -d $dir ]] && [[ -n $(\ls $dir) ]]; then
        for x in $dir/X*; do
            echo ":${x#$dir/X}"
        done
    else
        echo "X11 dir does not exist!"
    fi
}

q() {
    if [[ -z $(installed tmux) ]] ||
       [[ -z $TMUX ]] ||
       [[ $(tmux list-panes | wc -l) -ne 1 ]] ||
       [[ $(tmux list-windows | wc -l) -ne 1 ]]
    then
        exit 0
    fi

    local session="$(tmux display-message -p "#S")"
    local clients="$(tmux list-clients | \grep $session | wc -l)"

    if [[ $clients -eq 1 ]]; then
        \cd
        [[ ! -f $HOME/.milesrc.local ]] || . $HOME/.milesrc.local
        tmux clear-history
    fi

    tmux detach-client
}

rat() {
    local file
    for file in "$@"; do
        echo "### $file ###"
        cat $file
        echo
    done
}

if [[ -n $(installed vim) ]]; then
    rogue() {
        if [[ ! -d $HOME/.vim/bundle/rogue.vim ]]; then
            echo "rogue.vim is not installed"
            return
        fi

        local save_file
        if [[ -f $HOME/.rogue_vim.save ]]; then
            save_file="$HOME/rogue_vim.save"
            cp -a $HOME/.rogue_vim.save $save_file
        fi
        vim -c "Rogue $save_file" -c q
        [[ ! -f $save_file ]] || mv $save_file $HOME/.rogue_vim.save
        rm -f $HOME/rogue_vim.scores
    }
fi

sample_color() {
    local i
    local black="\e[30m"
    local reset="\e[0m"
    local white="\e[37m"
    for i in "$@"; do
        echo -e "\e[48;5;${i}m$black $i $white $i $reset"
    done
}

if [[ -n "$(installed vim)" ]] || [[ -n "$(installed vi)" ]]; then
    function vim() {
        local vi="$(installed vim)"
        [[ -z $vi ]] && vi="$(installed vi)"
        [[ -z $(command -v sudo) ]] && $vi $@ && return $?

        local i
        local sudo

        for i in "$@"; do
            case "$i" in
                "/dev/null") continue ;;
                -*) continue ;;
            esac
            if [[ -e $i ]]; then
                [[ ! -w $i ]] && sudo="true" && break
            elif [[ -d $(dirname $i) ]]; then
                [[ ! -w $(dirname $i) ]] && sudo="true" && break
            fi
        done

        local num="$(
            \grep -Ev "^[#_]|false|git|nologin|postgres|root|sync" \
            /etc/passwd | wc -l
        )"
        [[ $num -le 1 ]] || unset sudo

        [[ -z $sudo ]] && $vi $@ && return $?
        sudo $vi $@
    }
fi
# }}}

case "$MILESRC_SHELL" in
    *bash)
        # {{{ Bash completions
        # Complete dbash
        if [[ -n $(installed docker) ]]; then
            _dbash_complete() {
                mapfile -t COMPREPLY < <(
                    docker ps | perl -lne \
                    '!/NAMES/ && /('$2'[^ ]*)$/ && print $1' | sort -u
                )
            }
            if [[ -n $(installed perl) ]]; then
                complete -F _dbash_complete dbash
            fi
        fi

        # Complete insync-headless
        if [[ -n $(installed insync-headless) ]]; then
            _insync_complete() {
                mapfile -t COMPREPLY < <(
                    insync-headless help | perl -lne \
                    '/^\s('$2'[^\s]+)/ && print $1' | sort -u
                )
            }
            if [[ -n $(installed perl) ]]; then
                complete -F _insync_complete insync-headless
            fi
        fi

        # Complete mspac
        if [[ -n $(installed mspac) ]]; then
            _mspac_complete() {
                mapfile -t COMPREPLY < <(
                    mspac --list-pellets | \grep -E "^$2" | sort -u
                )
            }
            complete -F _mspac_complete mspac
        fi

        # Complete notmux and sshrc scripts
        _hostname_complete() {
            if [[ -f $HOME/.ssh/config ]]; then
                mapfile -t COMPREPLY < <(
                    perl -lne '/^Host ([A-Za-z0-9]+)/ && print $1' \
                    $HOME/.ssh/config | \grep -E "^$2" | sort -u
                )
            fi
        }
        if [[ -n $(installed perl) ]]; then
            complete -F _hostname_complete notmux
            complete -F _hostname_complete sshrc
        fi

        # Complete vbox
        if [[ -n $(installed vboxmanage) ]]; then
            _vbox_complete() {
                mapfile -t COMPREPLY < <(
                    vboxmanage list vms | perl -lne \
                    '/^"('$2'.*)" .*/ && print $1' | sort -u
                )
            }
            if [[ -n $(installed perl) ]]; then
                complete -F _vbox_complete vbox
            fi
        fi
        # }}}
        ;;
    *zsh)
        # {{{ Zsh completions
        # Complete dbash
        if [[ -n $(installed docker) ]]; then
            _dbash_complete() {
                reply=($(
                    docker ps | \
                    perl -lne '!/NAMES/ && /('$1'[^ ]*)$/ && print $1'
                ))
            }
            if [[ -n $(installed perl) ]]; then
                compctl -K _dbash_complete dbash
            fi
        fi

        # Complete insync-headless
        if [[ -n $(installed insync-headless) ]]; then
            _insync_complete() {
                reply=($(
                    insync-headless help | \
                    perl -lne '/^\s([^\s]+)/ && print $1'
                ))
            }
            if [[ -n $(installed perl) ]]; then
                compctl -K _insync_complete insync-headless
            fi
        fi

        # Complete mspac
        if [[ -n $(installed mspac) ]]; then
            compdef _gnu_generic mspac
            _mspac_complete() {
                reply=($(mspac --list-pellets))
            }
            compctl -K _mspac_complete mspac
        fi

        # Complete notmux and sshrc scripts
        compdef notmux=ssh
        compdef sshrc=ssh

        # Complete vbox
        if [[ -n $(installed vboxmanage) ]]; then
            _vbox_complete() {
                reply=($(
                    vboxmanage list vms | perl -lne \
                    '/^"(.+)" .*/ && print $1' | sort -u
                ))
            }
            if [[ -n $(installed perl) ]]; then
                complete -F _vbox_complete vbox
            fi
        fi
        # }}}
        ;;
esac
