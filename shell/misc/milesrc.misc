# If not running interactively, don't do anything
[[ $- == *i* ]] || return

# Lots of old stuff in here.

# {{{ Colors
declare -A FX FG BG 2>/dev/null

if [[ $? == 0 ]]; then
    FX[default]="\e[0m"
    FX[normal]="\e[0m"
    FX[reset]="\e[0m"
    FX[bold]="\e[1m"
    FX[dim]="\e[2m"
    FX[faint]="\e[2m"
    FX[italic]="\e[3m"
    FX[underline]="\e[4m"
    FX[blink]="\e[5m"
    FX[blink_slow]="\e[5m"
    FX[blink_rapid]="\e[6m"
    FX[inverse]="\e[7m"
    FX[negative]="\e[7m"
    FX[swap]="\e[7m"
    FX[conceal]="\e[8m"
    FX[hide]="\e[8m"
    FX[crossed_out]="\e[9m"
    FX[strikethrough]="\e[9m"
    FX[fraktur]="\e[20m"
    FX[no_bold]="\e[21m"
    FX[no_dim]="\e[22m"
    FX[no_faint]="\e[22m"
    FX[no_italic]="\e[23m"
    FX[no_underline]="\e[24m"
    FX[no_blink]="\e[25m"
    FX[no_blink_slow]="\e[25m"
    FX[no_blink_rapid]="\e[26m"
    FX[no_inverse]="\e[27m"
    FX[no_negative]="\e[27m"
    FX[no_swap]="\e[27m"
    FX[no_conceal]="\e[28m"
    FX[no_hide]="\e[28m"
    FX[no_crossed_out]="\e[29m"
    FX[no_strikethrough]="\e[29m"

    FG[default]="\e[39m"
    BG[default]="\e[49m"

    FG[black]="\e[30m"
    BG[black]="\e[40m"
    FG[red]="\e[31m"
    BG[red]="\e[41m"
    FG[green]="\e[32m"
    BG[green]="\e[42m"
    FG[yellow]="\e[33m"
    BG[yellow]="\e[43m"
    FG[blue]="\e[34m"
    BG[blue]="\e[44m"
    FG[magenta]="\e[35m"
    BG[magenta]="\e[45m"
    FG[cyan]="\e[36m"
    BG[cyan]="\e[46m"
    FG[white]="\e[37m"
    BG[white]="\e[47m"
    FG[light_black]="\e[90m"
    BG[light_black]="\e[100m"
    FG[light_red]="\e[91m"
    BG[light_red]="\e[101m"
    FG[light_green]="\e[92m"
    BG[light_green]="\e[102m"
    FG[light_yellow]="\e[93m"
    BG[light_yellow]="\e[103m"
    FG[light_blue]="\e[94m"
    BG[light_blue]="\e[104m"
    FG[light_magenta]="\e[95m"
    BG[light_magenta]="\e[105m"
    FG[light_cyan]="\e[96m"
    BG[light_cyan]="\e[106m"
    FG[light_white]="\e[97m"
    BG[light_white]="\e[107m"

    # Fill the color maps.
    for color in {000..256}; do
        FG[$color]="\e[38;5;${color}m"
        BG[$color]="\e[48;5;${color}m"
    done; unset color

    export FX
    export FG
    export BG
fi
# }}}

# {{{ Env Vars
# Terminal stuff
export TERM="xterm-256color"
# [[ -n $XTERM_VERSION ]] || export TERM="screen-256color"
export TERMCMD="xterm"

# Command args
case "$(uname -s)" in
    "Darwin") export NANO_ARGS="-m" ;;
    *) export NANO_ARGS="-um" ;;
esac

# Android
[[ -d $HOME/Android/Sdk ]] && export ANDROID_HOME="$HOME/Android/Sdk"
# }}}

# {{{ PATH
# }}}

# {{{ Prompt
# }}}

# {{{ Aliases
[[ -z $(command -v nano) ]] || alias nano="\nano $NANO_ARGS"
alias weather="clear; curl -s wttr.in/~Lafayette,IN | head -n -2"
# }}}

# {{{ Functions
add_to_path() {
    local arg
    local dir

    for arg in "$@"; do
        if [[ -d $arg ]]; then
            while read -r dir; do
                \cd $dir
                export PATH="$PATH:$(pwd)"
                \cd - >/dev/null
            done < <(
                find -L $arg -name ".*" -prune -o -type d -print \
                2>/dev/null
            )
        fi
    done
}

list_displays() {
    local dir="/tmp/.X11-unix"
    local x

    if [[ -d $dir ]] && [[ -n $(ls $dir) ]]; then
        for x in $dir/X*; do
            echo ":${x#$dir/X}"
        done
    else
        echo "X11 dir does not exist!"
    fi
}

# Lists directories in PROJS and allows quick cd'ing to them
function lsp() {
    [[ -d $PROJS ]] || return 0

    local count="0"
    local prev=""

    # Find repos that are not archived and not submodules
    while read -r dir; do
        if [[ -z $prev ]] ||
           [[ -z $(echo "${dir#$PROJS/}" | grep -Ps "$prev") ]]
        then
            ((count += 1))
            prev="${dir#$PROJS/}"

            if [[ $# -eq 0 ]]; then
                printf "%03d %s\n" $count $prev
            elif [[ $count -eq $1 ]]; then
                \cd $dir
                return 0
            fi
        fi
    done < <(
        find -L $PROJS -mindepth 1 -path "*archived*" -prune -o \
        -name ".git" -exec dirname {} + 2>/dev/null | sort
    ); unset dir
}

q() {
    if [[ -z $(command -v tmux) ]] ||
       [[ -z $TMUX ]] ||
       [[ $(tmux list-panes | wc -l) -ne 1 ]] ||
       [[ $(tmux list-windows | wc -l) -ne 1 ]]
    then
        exit 0
    fi

    local session="$(tmux display-message -p "#S")"
    local clients="$(tmux list-clients | grep -cs "$session")"

    if [[ $clients -eq 1 ]]; then
        \cd
        [[ ! -f $HOME/.milesrc.local ]] || . $HOME/.milesrc.local
        tmux clear-history
    fi

    tmux detach-client
}

rat() {
    local file
    for file in "$@"; do
        echo "### $file ###"
        cat $file
        echo
    done
}

if [[ -n $(command -v vim) ]]; then
    rogue() {
        if [[ ! -d $HOME/.vim/bundle/rogue.vim ]]; then
            echo "rogue.vim is not installed"
            return
        fi

        local save_file
        if [[ -f $HOME/.rogue_vim.save ]]; then
            save_file="$HOME/rogue_vim.save"
            cp -a $HOME/.rogue_vim.save $save_file
        fi
        vim -c "Rogue $save_file" -c q
        [[ ! -f $save_file ]] || mv $save_file $HOME/.rogue_vim.save
        rm -f $HOME/rogue_vim.scores
    }
fi

sample_color() {
    local i
    local black="\e[30m"
    local reset="\e[0m"
    local white="\e[37m"
    for i in "$@"; do
        echo -e "\e[48;5;${i}m$black $i $white $i $reset"
    done
}

if [[ -n "$(command -v vim)" ]] || [[ -n "$(command -v vi)" ]]; then
    function vim() {
        local vi="$(command -v vim)"
        [[ -z $vi ]] && vi="$(command -v vi)"
        [[ -z $(command -v sudo) ]] && $vi $@ && return $?

        local i
        local sudo

        for i in "$@"; do
            case "$i" in
                "/dev/null") continue ;;
                -*) continue ;;
            esac
            if [[ -e $i ]]; then
                [[ ! -w $i ]] && sudo="true" && break
            elif [[ -d $(dirname $i) ]]; then
                [[ ! -w $(dirname $i) ]] && sudo="true" && break
            fi
        done

        local num="$(
            grep -Pv "^[#_]|false|git|nologin|postgres|root|sync" \
            /etc/passwd | wc -l
        )"
        [[ $num -le 1 ]] || unset sudo

        [[ -z $sudo ]] && $vi $@ && return $?
        sudo $vi $@
    }
fi
# }}}

case "$MILESRC_SHELL" in
    *bash)
        # {{{ Bash completions
        # Complete insync-headless
        if [[ -n $(command -v insync-headless) ]]; then
            _insync_complete() {
                mapfile -t COMPREPLY < <(
                    insync-headless help | perl -lne \
                    '/^\s('$2'[^\s]+)/ && print $1' | sort -u
                )
            }
            if [[ -n $(command -v perl) ]]; then
                complete -F _insync_complete insync-headless
            fi
        fi

        # Complete mspac
        if [[ -n $(command -v mspac) ]]; then
            _mspac_complete() {
                mapfile -t COMPREPLY < <(
                    mspac --list-pellets | grep -Ps "^$2" | sort -u
                )
            }
            complete -F _mspac_complete mspac
        fi

        # Complete notmux and sshrc scripts
        _hostname_complete() {
            if [[ -f $HOME/.ssh/config ]]; then
                mapfile -t COMPREPLY < <(
                    perl -lne '/^Host ([A-Za-z0-9]+)/ && print $1' \
                    $HOME/.ssh/config | grep -Ps "^$2" | sort -u
                )
            fi
        }
        if [[ -n $(command -v perl) ]]; then
            complete -F _hostname_complete notmux
            complete -F _hostname_complete sshrc
        fi

        # Complete vbox
        if [[ -n $(command -v vboxmanage) ]]; then
            _vbox_complete() {
                mapfile -t COMPREPLY < <(
                    vboxmanage list vms | perl -lne \
                    '/^"('$2'.*)" .*/ && print $1' | sort -u
                )
            }
            if [[ -n $(command -v perl) ]]; then
                complete -F _vbox_complete vbox
            fi
        fi
        # }}}
        ;;
    *zsh)
        # {{{ Zsh completions
        # Complete insync-headless
        if [[ -n $(command -v insync-headless) ]]; then
            _insync_complete() {
                reply=($(
                    insync-headless help | \
                    perl -lne '/^\s([^\s]+)/ && print $1'
                ))
            }
            if [[ -n $(command -v perl) ]]; then
                compctl -K _insync_complete insync-headless
            fi
        fi

        # Complete mspac
        if [[ -n $(command -v mspac) ]]; then
            compdef _gnu_generic mspac
            _mspac_complete() {
                reply=($(mspac --list-pellets))
            }
            compctl -K _mspac_complete mspac
        fi

        # Complete notmux and sshrc scripts
        compdef notmux=ssh
        compdef sshrc=ssh

        # Complete vbox
        if [[ -n $(command -v vboxmanage) ]]; then
            _vbox_complete() {
                reply=($(
                    vboxmanage list vms | perl -lne \
                    '/^"(.+)" .*/ && print $1' | sort -u
                ))
            }
            if [[ -n $(command -v perl) ]]; then
                complete -F _vbox_complete vbox
            fi
        fi
        # }}}
        ;;
esac
